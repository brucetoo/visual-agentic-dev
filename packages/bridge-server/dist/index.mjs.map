{"version":3,"sources":["../src/server/WebSocketServer.ts","../src/claude/ClaudeCodeRunner.ts","../src/claude/PromptBuilder.ts","../src/utils/apple-script.ts","../src/utils/DevTerminal.ts","../src/utils/ProjectUtils.ts","../src/index.ts"],"sourcesContent":["import { WebSocketServer, WebSocket } from 'ws';\nimport { ClaudeCodeRunner } from '../claude/ClaudeCodeRunner';\nimport { resolveProjectPath, deriveProjectPathFromSource } from '../utils/ProjectUtils';\nimport type { ClientMessage, ServerMessage, StreamMessage, ResolveProjectPathPayload } from '../types';\n\n/**\n * WebSocket server that bridges browser extension to Claude Code CLI\n * No authentication required - for local development use only\n */\nexport class VDevWebSocketServer {\n    private wss: WebSocketServer;\n    private runners: Map<string, ClaudeCodeRunner> = new Map();\n\n    constructor(port: number = 9527) {\n        this.wss = new WebSocketServer({ port });\n\n        this.wss.on('connection', this.handleConnection.bind(this));\n\n        console.log(`[VDev Bridge] WebSocket server running on ws://localhost:${port}`);\n    }\n\n    private handleConnection(ws: WebSocket): void {\n        console.log('[VDev Bridge] Client connected');\n        const clientId = Math.random().toString(36).substring(7);\n\n        ws.on('message', async (data) => {\n            try {\n                const message: ClientMessage = JSON.parse(data.toString());\n\n                // Handle different message types\n                switch (message.type) {\n                    case 'EXECUTE_TASK':\n                        await this.handleExecuteTask(ws, message, clientId);\n                        break;\n                    case 'CANCEL_TASK':\n                        this.handleCancelTask(ws, message, clientId);\n                        break;\n                    case 'GET_STATUS':\n                        this.handleGetStatus(ws, message, clientId);\n                        break;\n                    case 'RESOLVE_PROJECT_PATH':\n                        await this.handleResolveProjectPath(ws, message);\n                        break;\n                }\n            } catch (error) {\n                console.error('[VDev Bridge] Message error:', error);\n            }\n        });\n\n        ws.on('close', () => {\n            console.log(`[VDev Bridge] Client ${clientId} disconnected`);\n            // Cancel any running tasks for this client\n            const runner = this.runners.get(clientId);\n            if (runner) {\n                runner.cancel();\n                this.runners.delete(clientId);\n            }\n        });\n    }\n\n    private async handleExecuteTask(\n        ws: WebSocket,\n        message: ClientMessage,\n        clientId: string\n    ): Promise<void> {\n        const payload = message.payload as { source: { fileName: string; lineNumber: number; columnNumber: number }; instruction: string; projectPath: string };\n        const { source, instruction, projectPath: extensionProvidedPath } = payload;\n\n        // Derive project path from source file - this is more reliable than extension-provided path\n        // because the source file path always points to the actual file location\n        const projectPath = deriveProjectPathFromSource(source.fileName) || extensionProvidedPath;\n\n        console.log(`[VDev Bridge] Executing task for ${projectPath}`);\n        console.log(`[VDev Bridge] Target: ${source.fileName}:${source.lineNumber}`);\n        console.log(`[VDev Bridge] Instruction: ${instruction.slice(0, 100)}...`);\n\n        this.send(ws, {\n            type: 'TASK_STARTED',\n            id: message.id,\n            payload: { status: 'running' },\n        });\n\n        const runner = new ClaudeCodeRunner();\n        this.runners.set(clientId, runner);\n\n        try {\n            const result = await runner.execute({\n                projectPath,\n                source,\n                instruction,\n                onLog: (log: string) => {\n                    console.log(`[VDev Bridge log] ${log}`);\n                    this.send(ws, {\n                        type: 'TASK_LOG',\n                        id: message.id,\n                        payload: { log },\n                    });\n                },\n            });\n\n            console.log(`[VDev Bridge] Task completed. Files modified: ${result.filesModified.join(', ')}`);\n\n            this.send(ws, {\n                type: 'TASK_COMPLETED',\n                id: message.id,\n                payload: result,\n            });\n        } catch (error) {\n            console.error('[VDev Bridge] Task error:', error);\n            this.send(ws, {\n                type: 'TASK_ERROR',\n                id: message.id,\n                payload: { error: (error as Error).message },\n            });\n        } finally {\n            this.runners.delete(clientId);\n        }\n    }\n\n    private handleCancelTask(\n        ws: WebSocket,\n        message: ClientMessage,\n        clientId: string\n    ): void {\n        const runner = this.runners.get(clientId);\n        if (runner) {\n            runner.cancel();\n            this.runners.delete(clientId);\n            console.log(`[VDev Bridge] Task cancelled for client ${clientId}`);\n        }\n\n        this.send(ws, {\n            type: 'TASK_COMPLETED',\n            id: message.id,\n            payload: { cancelled: true },\n        });\n    }\n\n    private handleGetStatus(\n        ws: WebSocket,\n        message: ClientMessage,\n        clientId: string\n    ): void {\n        const runner = this.runners.get(clientId);\n        this.send(ws, {\n            type: 'TASK_PROGRESS',\n            id: message.id,\n            payload: {\n                running: runner?.isRunning() ?? false\n            },\n        });\n    }\n\n    private async handleResolveProjectPath(\n        ws: WebSocket,\n        message: ClientMessage\n    ): Promise<void> {\n        const payload = message.payload as ResolveProjectPathPayload;\n        const port = payload?.port;\n\n        if (!port) {\n            this.send(ws, {\n                type: 'PROJECT_PATH_RESOLVED',\n                id: message.id,\n                payload: { projectPath: null, error: 'No port provided' },\n            });\n            return;\n        }\n\n        console.log(`[VDev Bridge] Resolving project path for port ${port}`);\n\n        const projectPath = await resolveProjectPath(port);\n\n        this.send(ws, {\n            type: 'PROJECT_PATH_RESOLVED',\n            id: message.id,\n            payload: { projectPath },\n        });\n    }\n\n    private send(ws: WebSocket, message: ServerMessage): void {\n        if (ws.readyState === WebSocket.OPEN) {\n            ws.send(JSON.stringify(message));\n        }\n    }\n\n    close(): void {\n        // Cancel all running tasks\n        for (const runner of this.runners.values()) {\n            runner.cancel();\n        }\n        this.runners.clear();\n\n        this.wss.close();\n        console.log('[VDev Bridge] Server closed');\n    }\n}\n","import { createHash } from 'crypto';\nimport type { SourceLocation, ExecuteResult } from '../types';\nimport { PromptBuilder } from './PromptBuilder';\nimport { DevTerminal } from '../utils/DevTerminal';\n\ninterface ExecuteOptions {\n    projectPath: string;\n    source: SourceLocation;\n    instruction: string;\n    onLog?: (log: string) => void;\n}\n\n/**\n * Executes Claude Code CLI via interactive iTerm session\n */\nexport class ClaudeCodeRunner {\n    async execute(options: ExecuteOptions): Promise<ExecuteResult> {\n        const { projectPath, source, instruction, onLog } = options;\n\n        const prompt = PromptBuilder.build({ source, instruction });\n\n        // Generate a stable ID for the project session based on path\n        const projectId = createHash('md5').update(projectPath).digest('hex').substring(0, 8);\n\n        try {\n            onLog?.(`[ClaudeRunner] Target Session: vdev-${projectId}`);\n\n            const exists = await DevTerminal.sessionExists(projectId);\n\n            if (!exists) {\n                onLog?.('[ClaudeRunner] Launching new iTerm session...');\n                await DevTerminal.launchSession(projectId, projectPath);\n            } else {\n                onLog?.('[ClaudeRunner] Reusing existing session');\n            }\n\n            onLog?.('[ClaudeRunner] Waiting for ccr to be ready...');\n            const ready = await DevTerminal.ensureAgentRunning(projectId);\n\n            if (!ready) {\n                onLog?.('[ClaudeRunner] Warning: ccr may not be fully ready');\n            }\n\n            onLog?.('[ClaudeRunner] Sending instruction...');\n            await DevTerminal.sendInput(projectId, prompt);\n\n            return {\n                success: true,\n                filesModified: [], // Interactive mode doesn't track this automatically\n                messages: [],\n            };\n        } catch (error) {\n            onLog?.(`[ClaudeRunner] Error: ${(error as Error).message}`);\n            throw error;\n        }\n    }\n\n    cancel(): void {\n        // No-op for interactive terminal mode\n        // User handles cancellation in the terminal\n    }\n\n    isRunning(): boolean {\n        return false; // Stateless\n    }\n}\n","import type { SourceLocation } from '../types';\n\ninterface BuildOptions {\n    source: SourceLocation;\n    instruction: string;\n}\n\n/**\n * Builds prompts for Claude Code CLI\n */\nexport class PromptBuilder {\n    static build(options: BuildOptions): string {\n        const { source, instruction } = options;\n        const startLine = Math.max(1, source.lineNumber - 10);\n        const endLine = source.lineNumber + 10;\n\n        return `\n你需要帮我修改代码。\n\n## 目标位置\n- 文件: ${source.fileName}\n- 行号: ${source.lineNumber}\n- 列号: ${source.columnNumber}\n\n请先使用 view_file 工具查看这个文件的第 ${startLine} 到 ${endLine} 行，了解上下文。\n\n## 任务\n${instruction}\n\n## 要求\n1. 只修改必要的代码，保持代码风格一致\n2. 如果需要添加新组件，请在合适的位置添加 import\n3. 如果需要添加样式，请使用内联样式或在合适的样式文件中添加\n4. 完成后简要说明你做了什么修改\n`.trim();\n    }\n}\n","import { exec } from 'child_process';\nimport { promisify } from 'util';\n\nconst execAsync = promisify(exec);\n\nexport async function runAppleScript(script: string): Promise<string> {\n    try {\n        const { stdout } = await execAsync(`osascript -e '${script.replace(/'/g, \"'\\\\''\")}'`);\n        return stdout.trim();\n    } catch (error) {\n        throw new Error(`AppleScript execution failed: ${(error as Error).message}`);\n    }\n}\n\n/**\n * Escapes a string for use in AppleScript string literals.\n * Wraps it in double quotes and escapes backslashes and double quotes.\n */\nexport function escapeForAppleScript(text: string): string {\n    return text.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"');\n}\n","import { runAppleScript, escapeForAppleScript } from './apple-script';\n\nexport class DevTerminal {\n    // Track window IDs by project ID\n    private static windowIdMap = new Map<string, number>();\n    // Track sessions where we've started ccr code\n    private static activeSessions = new Set<string>();\n\n    /**\n     * Checks if a session with the given project ID exists\n     */\n    static async sessionExists(projectId: string): Promise<boolean> {\n        const windowId = this.windowIdMap.get(projectId);\n        if (!windowId) return false;\n\n        try {\n            // Check if window with this ID still exists\n            const script = `\n                tell application \"iTerm\"\n                    repeat with w in windows\n                        if id of w is ${windowId} then\n                            return \"true\"\n                        end if\n                    end repeat\n                end tell\n                return \"false\"\n            `;\n            const result = await runAppleScript(script);\n            return result === 'true';\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Gets the current terminal content for the project's window\n     */\n    static async getSessionContent(projectId: string): Promise<string> {\n        const windowId = this.windowIdMap.get(projectId);\n        if (!windowId) return '';\n\n        try {\n            const script = `\n                tell application \"iTerm\"\n                    repeat with w in windows\n                        if id of w is ${windowId} then\n                            return contents of current session of w\n                        end if\n                    end repeat\n                end tell\n                return \"\"\n            `;\n            return await runAppleScript(script);\n        } catch (e) {\n            return '';\n        }\n    }\n\n    /**\n     * Waits for ccr code to be ready (polls for prompt indicator)\n     */\n    static async waitForAgentReady(projectId: string, timeoutMs: number = 30000): Promise<boolean> {\n        const startTime = Date.now();\n        const pollInterval = 500;\n\n        while (Date.now() - startTime < timeoutMs) {\n            const content = await this.getSessionContent(projectId);\n\n            // ccr code shows these indicators when ready\n            if (content.includes('Claude Code v') ||\n                content.includes('Welcome back') ||\n                content.includes('/model to try') ||\n                content.includes('Tips for getting')) {\n                return true;\n            }\n\n            await new Promise(resolve => setTimeout(resolve, pollInterval));\n        }\n\n        return false;\n    }\n\n    /**\n     * Launches a new iTerm window/session for the project and stores its ID\n     */\n    static async launchSession(projectId: string, projectPath: string): Promise<void> {\n        // Create window and get its ID\n        const script = `\n            tell application \"iTerm\"\n                set newWindow to (create window with default profile)\n                set windowId to id of newWindow\n                tell current session of newWindow\n                    write text \"cd ${escapeForAppleScript(projectPath)}\"\n                    write text \"clear\"\n                    write text \"ccr code\"\n                end tell\n                return windowId\n            end tell\n        `;\n        const windowIdStr = await runAppleScript(script);\n        const windowId = parseInt(windowIdStr, 10);\n\n        if (!isNaN(windowId)) {\n            this.windowIdMap.set(projectId, windowId);\n        }\n\n        this.activeSessions.add(projectId);\n    }\n\n    /**\n     * Ensures ccr code is running and ready for input\n     */\n    static async ensureAgentRunning(projectId: string): Promise<boolean> {\n        if (!this.activeSessions.has(projectId)) {\n            await this.sendInput(projectId, 'ccr code');\n            this.activeSessions.add(projectId);\n        }\n\n        return await this.waitForAgentReady(projectId);\n    }\n\n    /**\n     * Sends input to the session using window ID\n     */\n    static async sendInput(projectId: string, text: string): Promise<void> {\n        const windowId = this.windowIdMap.get(projectId);\n        if (!windowId) {\n            throw new Error(`No window found for project ${projectId}`);\n        }\n\n        const escapedText = escapeForAppleScript(text);\n        const script = `\n            tell application \"iTerm\"\n                repeat with w in windows\n                    if id of w is ${windowId} then\n                        tell current session of w\n                            write text \"${escapedText}\"\n                            select\n                        end tell\n                        set index of w to 1\n                        activate\n                        return\n                    end if\n                end repeat\n            end tell\n        `;\n        await runAppleScript(script);\n    }\n}\n","import { exec } from 'child_process';\nimport { promisify } from 'util';\nimport * as path from 'path';\nimport * as fs from 'fs';\n\nconst execAsync = promisify(exec);\n\n/**\n * Resolve project root path from a port number using lsof (macOS).\n * This finds the process listening on the given port and extracts its CWD,\n * then searches upward for package.json to find the project root.\n */\nexport async function resolveProjectPath(port: number): Promise<string | null> {\n    try {\n        // Step 1: Find PID of process listening on the port\n        const { stdout: lsofOutput } = await execAsync(\n            `lsof -i :${port} -P -n | grep LISTEN | awk '{print $2}' | head -1`\n        );\n        const pid = lsofOutput.trim();\n\n        if (!pid) {\n            console.log(`[ProjectUtils] No process found listening on port ${port}`);\n            return null;\n        }\n\n        console.log(`[ProjectUtils] Found PID ${pid} for port ${port}`);\n\n        // Step 2: Get the CWD of that process\n        const { stdout: cwdOutput } = await execAsync(\n            `lsof -p ${pid} | grep cwd | awk '{print $NF}'`\n        );\n        const cwd = cwdOutput.trim();\n\n        if (!cwd) {\n            console.log(`[ProjectUtils] Could not determine CWD for PID ${pid}`);\n            return null;\n        }\n\n        console.log(`[ProjectUtils] Process CWD: ${cwd}`);\n\n        // Step 3: Find project root by looking for package.json upward\n        const projectRoot = findProjectRoot(cwd);\n\n        if (projectRoot) {\n            console.log(`[ProjectUtils] Resolved project root: ${projectRoot}`);\n        } else {\n            console.log(`[ProjectUtils] Could not find project root from ${cwd}`);\n        }\n\n        return projectRoot;\n    } catch (error) {\n        console.error('[ProjectUtils] Error resolving project path:', error);\n        return null;\n    }\n}\n\n/**\n * Derive project root path from a source file path.\n * This is more reliable than port-based detection when source files come from different projects.\n */\nexport function deriveProjectPathFromSource(sourceFilePath: string): string | null {\n    if (!sourceFilePath || !path.isAbsolute(sourceFilePath)) {\n        console.log(`[ProjectUtils] Invalid source file path: ${sourceFilePath}`);\n        return null;\n    }\n\n    const dir = path.dirname(sourceFilePath);\n    const projectRoot = findProjectRoot(dir);\n\n    if (projectRoot) {\n        console.log(`[ProjectUtils] Derived project root from source: ${projectRoot}`);\n    } else {\n        console.log(`[ProjectUtils] Could not derive project root from source: ${sourceFilePath}`);\n    }\n\n    return projectRoot;\n}\n\n/**\n * Find project root by searching upward for package.json\n */\nfunction findProjectRoot(startPath: string): string | null {\n    let currentPath = startPath;\n\n    while (currentPath !== '/') {\n        const packageJsonPath = path.join(currentPath, 'package.json');\n\n        if (fs.existsSync(packageJsonPath)) {\n            return currentPath;\n        }\n\n        currentPath = path.dirname(currentPath);\n    }\n\n    return null;\n}\n\n","import { VDevWebSocketServer } from './server/WebSocketServer';\nimport { TokenAuth } from './auth/TokenAuth';\n\nexport interface ServerOptions {\n    port?: number;\n}\n\n/**\n * Start the Visual Dev Bridge Server\n */\nexport function startServer(options: ServerOptions = {}): VDevWebSocketServer {\n    const port = options.port || 9527;\n\n    console.log('[VDev Bridge] Starting server...');\n\n    const server = new VDevWebSocketServer(port);\n\n    // Handle graceful shutdown\n    process.on('SIGINT', () => {\n        console.log('\\n[VDev Bridge] Shutting down...');\n        server.close();\n        process.exit(0);\n    });\n\n    process.on('SIGTERM', () => {\n        server.close();\n        process.exit(0);\n    });\n\n    return server;\n}\n\n// Re-export types and classes\nexport { VDevWebSocketServer } from './server/WebSocketServer';\nexport { ClaudeCodeRunner } from './claude/ClaudeCodeRunner';\nexport { PromptBuilder } from './claude/PromptBuilder';\nexport * from './types';\n"],"mappings":"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","names":["exec","promisify","execAsync"]}