{"version":3,"sources":["../src/index.ts","../src/server/WebSocketServer.ts","../src/claude/PromptBuilder.ts","../src/claude/ClaudeCodeRunner.ts","../src/utils/ProjectUtils.ts","../src/utils/TerminalManager.ts","../src/utils/ToolManager.ts"],"sourcesContent":["import { VDevWebSocketServer } from './server/WebSocketServer';\nimport { TokenAuth } from './auth/TokenAuth';\n\nexport interface ServerOptions {\n    port?: number;\n}\n\n/**\n * Start the Visual Dev Bridge Server\n */\nexport function startServer(options: ServerOptions = {}): VDevWebSocketServer {\n    const port = options.port || 9527;\n\n    console.log('[VDev Bridge] Starting server...');\n\n    const server = new VDevWebSocketServer(port);\n\n    // Handle graceful shutdown\n    process.on('SIGINT', () => {\n        console.log('\\n[VDev Bridge] Shutting down...');\n        server.close();\n        process.exit(0);\n    });\n\n    process.on('SIGTERM', () => {\n        server.close();\n        process.exit(0);\n    });\n\n    return server;\n}\n\n// Re-export types and classes\nexport { VDevWebSocketServer } from './server/WebSocketServer';\nexport { ClaudeCodeRunner } from './claude/ClaudeCodeRunner';\nexport { PromptBuilder } from './claude/PromptBuilder';\nexport * from './types';\n","import { WebSocketServer, WebSocket } from 'ws';\nimport * as crypto from 'crypto';\nimport { ClaudeCodeRunner } from '../claude/ClaudeCodeRunner';\nimport { resolveProjectPath, deriveProjectPathFromSource } from '../utils/ProjectUtils';\nimport { TerminalManager } from '../utils/TerminalManager';\nimport type { ClientMessage, ServerMessage, StreamMessage, ResolveProjectPathPayload, TerminalDataPayload, TerminalResizePayload } from '../types';\n\n/**\n * WebSocket server that bridges browser extension to Claude Code CLI\n * No authentication required - for local development use only\n */\nexport class VDevWebSocketServer {\n    private wss: WebSocketServer;\n    private runners: Map<string, ClaudeCodeRunner> = new Map();\n    private terminalManager: TerminalManager = new TerminalManager();\n\n    // Mapping from sessionId (projectPath hash) to connected clients\n    private sessionClients: Map<string, Set<WebSocket>> = new Map();\n\n    // Track which sessions strictly have listeners attached to avoid duplicates\n    private attachedSessions: Set<string> = new Set();\n\n    constructor(port: number = 9527) {\n        this.wss = new WebSocketServer({ port });\n\n        this.wss.on('connection', this.handleConnection.bind(this));\n\n        // Listen for readiness events\n        this.terminalManager.onReady((sessionId) => {\n            console.log(`[VDev Bridge] Session ${sessionId} is ready. Broadcasting to clients...`);\n            this.broadcastToSession(sessionId, {\n                type: 'TERMINAL_READY',\n                id: 'broadcast',\n                payload: { sessionId }\n            } as any); // Type cast until we strictly type broadcastToSession arg\n        });\n\n        console.log(`[VDev Bridge] WebSocket server running on ws://localhost:${port}`);\n    }\n\n    private getSessionId(projectPath: string): string {\n        // Use a stable hash of the project path as the session ID\n        return crypto.createHash('md5').update(projectPath).digest('hex');\n    }\n\n    private handleConnection(ws: WebSocket): void {\n        console.log('[VDev Bridge] Client connected');\n        // ephemeral ID for task tracking, though tasks might be better keyed by project now too?\n        // For task execution, we still use one runner per request? \n        // Or should runner be per session?\n        // Currently architecture assumes ephemeral runner. Let's keep clientId for runner/task tracking.\n        const clientId = Math.random().toString(36).substring(7);\n\n        // Track subscriptions for this client to clean up on disconnect\n        const subscribedSessions: Set<string> = new Set();\n\n        ws.on('message', async (data) => {\n            try {\n                const message: ClientMessage = JSON.parse(data.toString());\n\n                // Handle different message types\n                switch (message.type) {\n                    case 'EXECUTE_TASK':\n                        await this.handleExecuteTask(ws, message, clientId, subscribedSessions);\n                        break;\n                    case 'CANCEL_TASK':\n                        this.handleCancelTask(ws, message, clientId);\n                        break;\n                    case 'GET_STATUS':\n                        this.handleGetStatus(ws, message, clientId);\n                        break;\n                    case 'RESOLVE_PROJECT_PATH':\n                        await this.handleResolveProjectPath(ws, message);\n                        break;\n                    case 'TERMINAL_DATA':\n                        await this.handleTerminalData(ws, message, subscribedSessions);\n                        break;\n                    case 'TERMINAL_RESIZE':\n                        this.handleTerminalResize(message);\n                        break;\n                    // @ts-ignore - Handle new message type\n                    case 'TERMINAL_INIT':\n                        // @ts-ignore\n                        await this.handleTerminalInit(ws, message, subscribedSessions);\n                        break;\n                    // @ts-ignore - Handle new message type\n                    case 'TERMINAL_RESET':\n                        this.handleTerminalReset(message);\n                        break;\n                }\n            } catch (error) {\n                console.error('[VDev Bridge] Message error:', error);\n            }\n        });\n\n        ws.on('close', () => {\n            console.log(`[VDev Bridge] Client ${clientId} disconnected`);\n\n            // Cancel any running task\n            const runner = this.runners.get(clientId);\n            if (runner) {\n                runner.cancel();\n                this.runners.delete(clientId);\n            }\n\n            // Unsubscribe from sessions\n            for (const sessionId of subscribedSessions) {\n                const clients = this.sessionClients.get(sessionId);\n                if (clients) {\n                    clients.delete(ws);\n                    if (clients.size === 0) {\n                        this.sessionClients.delete(sessionId);\n                        // Optional: Terminate session if no clients? \n                        // User requested \"reuse existing session\", so we KEEP it alive.\n                        // But maybe we should have a timeout? For now, keep it simple: manual kill or server restart.\n                    }\n                }\n            }\n        });\n    }\n\n    // Track which PTYs we are currently listening to, to handle restarts (Swap PTY)\n    private activePtys: Map<string, any> = new Map();\n\n    private async ensureSession(sessionId: string, projectPath: string, useYolo: boolean = false): Promise<void> {\n        // We modify getOrCreateSession signature on the fly if needed, but here it's fine.\n        // If YOLO mode changes, this returns a NEW pty object.\n        const sessionPty = await this.terminalManager.getOrCreateSession(sessionId, projectPath, useYolo);\n\n        const lastPty = this.activePtys.get(sessionId);\n\n        // If we haven't seen this PTY before (New session OR Restarted session), attach listener\n        if (lastPty !== sessionPty) {\n            console.log(`[VDev Bridge] Attaching listener to new PTY for session ${sessionId}`);\n            sessionPty.onData((data: string) => {\n                this.broadcastToSession(sessionId, data);\n            });\n            this.activePtys.set(sessionId, sessionPty);\n        }\n    }\n\n    private subscribeToSession(ws: WebSocket, sessionId: string, subscribedSessions: Set<string>): void {\n        // Enforce SINGLE active session per client socket.\n        // Iterate over a COPY to safely modify the original Set during iteration.\n        const currentSessions = Array.from(subscribedSessions);\n\n        for (const oldSessionId of currentSessions) {\n            if (oldSessionId !== sessionId) {\n                console.log(`[VDev Bridge] Unsubscribing client from old session: ${oldSessionId}`);\n                const oldClients = this.sessionClients.get(oldSessionId);\n                if (oldClients) {\n                    oldClients.delete(ws);\n                    if (oldClients.size === 0) {\n                        this.sessionClients.delete(oldSessionId);\n                        // We still keep the process alive in TerminalManager\n                    }\n                }\n                subscribedSessions.delete(oldSessionId);\n            }\n        }\n\n        if (!subscribedSessions.has(sessionId)) {\n            console.log(`[VDev Bridge] Subscribing client to new session: ${sessionId}`);\n            if (!this.sessionClients.has(sessionId)) {\n                this.sessionClients.set(sessionId, new Set());\n            }\n            this.sessionClients.get(sessionId)?.add(ws);\n            subscribedSessions.add(sessionId);\n        }\n    }\n\n    private broadcastToSession(sessionId: string, messageOrData: string | object): void {\n        const clients = this.sessionClients.get(sessionId);\n        if (clients && clients.size > 0) {\n            let payload: string;\n\n            if (typeof messageOrData === 'string') {\n                payload = JSON.stringify({\n                    type: 'TERMINAL_OUTPUT',\n                    id: 'stream',\n                    payload: { data: messageOrData }\n                });\n            } else {\n                payload = JSON.stringify(messageOrData);\n            }\n\n            for (const client of clients) {\n                if (client.readyState === WebSocket.OPEN) {\n                    client.send(payload);\n                }\n            }\n        }\n    }\n\n    private async handleTerminalInit(\n        ws: WebSocket,\n        message: ClientMessage,\n        subscribedSessions: Set<string>\n    ): Promise<void> {\n        const payload = message.payload as any;\n        const { projectPath, useYolo } = payload;\n\n        if (!projectPath) return;\n\n        console.log(`[VDev Bridge] Initializing terminal for ${projectPath}`);\n        const sessionId = this.getSessionId(projectPath);\n\n        this.subscribeToSession(ws, sessionId, subscribedSessions);\n        await this.ensureSession(sessionId, projectPath, !!useYolo);\n\n        // Replay history\n        const history = this.terminalManager.getHistory(sessionId);\n        if (history) {\n            this.send(ws, {\n                type: 'TERMINAL_OUTPUT',\n                id: message.id, // Response to INIT\n                payload: { data: history }\n            });\n        }\n\n        // Check readiness\n        if (this.terminalManager.isSessionReady(sessionId)) {\n            console.log(`[VDev Bridge] Session ${sessionId} is already READY. Notifying client.`);\n            this.send(ws, {\n                type: 'TERMINAL_READY',\n                id: message.id,\n                payload: { sessionId }\n            });\n        }\n    }\n\n    private async handleExecuteTask(\n        ws: WebSocket,\n        message: ClientMessage,\n        clientId: string,\n        subscribedSessions: Set<string>\n    ): Promise<void> {\n        const payload = message.payload as { source: { fileName: string; lineNumber: number; columnNumber: number }; instruction: string; projectPath: string };\n        const { source, instruction, projectPath: extensionProvidedPath } = payload;\n\n        const projectPath = deriveProjectPathFromSource(source.fileName) || extensionProvidedPath;\n        const sessionId = this.getSessionId(projectPath);\n\n        console.log(`[VDev Bridge] Executing task for ${projectPath} (Session: ${sessionId})`);\n\n        // Ensure we are subscribed to output\n        this.subscribeToSession(ws, sessionId, subscribedSessions);\n        await this.ensureSession(sessionId, projectPath, false);\n\n        // Note: For task execution we don't necessarily replay history as it might be confusing if user just wants to see new task.\n        // But if they just switched, maybe they want it?\n        // Let's stick to user request: \"Terminal history lost on switch/return\".\n        // If they are executing a task, they assume they are viewing that project.\n        // It's safe to replay history if this is a fresh subscription.\n        // But handleExecuteTask is usually called after they are already viewing?\n        // If they send a task without opening sidepanel first (unlikely in new flow), they might miss history.\n        // But let's leave it for now. User said \"when switching back... history is gone\".\n        // handleTerminalInit covers the \"switching back\" case.\n\n        this.send(ws, {\n            type: 'TASK_STARTED',\n            id: message.id,\n            payload: { status: 'running' },\n            projectPath,\n        });\n\n        // ... rest of execution logic ...\n        // We need to fetch the rest of the function or careful with replacement.\n        // The rest of this function creates the runner etc.\n        // Since I'm replacing the whole block range, I need to include it.\n\n        const runner = new ClaudeCodeRunner();\n        this.runners.set(clientId, runner);\n\n        try {\n            const result = await runner.execute({\n                projectPath,\n                source,\n                instruction,\n                onLog: (log: string) => {\n                    console.log(`[VDev Bridge log] ${log}`);\n                    this.send(ws, {\n                        type: 'TASK_LOG',\n                        id: message.id,\n                        payload: { log },\n                        projectPath,\n                    });\n                },\n                terminalManager: this.terminalManager,\n                sessionId: sessionId, // Use persistent session ID\n            });\n\n            console.log(`[VDev Bridge] Task completed. Files modified: ${result.filesModified.join(', ')}`);\n\n            this.send(ws, {\n                type: 'TASK_COMPLETED',\n                id: message.id,\n                payload: result,\n                projectPath,\n            });\n        } catch (error) {\n            console.error('[VDev Bridge] Task error:', error);\n            this.send(ws, {\n                type: 'TASK_ERROR',\n                id: message.id,\n                payload: { error: (error as Error).message },\n                projectPath,\n            });\n        } finally {\n            this.runners.delete(clientId);\n        }\n    }\n\n    private handleCancelTask(\n        ws: WebSocket,\n        message: ClientMessage,\n        clientId: string\n    ): void {\n        const runner = this.runners.get(clientId);\n        if (runner) {\n            runner.cancel();\n            this.runners.delete(clientId);\n            console.log(`[VDev Bridge] Task cancelled for client ${clientId}`);\n        }\n\n        // canceling a task might not have easy access to projectPath here unless we store it with runner?\n        // But the message ID matches the original request.\n        // The frontend might ignore it if it doesn't have projectPath?\n        // Or we should store projectPath in the runner map or something?\n        // For now, let's assume cancellation is global or we don't filter it strictly?\n        // Actually, if we filter STRICTLY, we need projectPath.\n        // Let's see if we can get it.\n        // We aren't storing it.\n        // Updating runner map to store metadata might be cleaner.\n        // But for minimal changes:\n        // The `TASK_COMPLETED` (cancelled) message is important.\n        // If I switch tabs, I probably don't care about the cancellation notification of the OLD tab.\n        // So if it's filtered out, that's actually CORRECT/FINE.\n        // The user won't see \"Task cancelled\" for a task in another project.\n\n        this.send(ws, {\n            type: 'TASK_COMPLETED',\n            id: message.id,\n            payload: { cancelled: true },\n        });\n    }\n\n    private handleGetStatus(\n        ws: WebSocket,\n        message: ClientMessage,\n        clientId: string\n    ): void {\n        const runner = this.runners.get(clientId);\n        this.send(ws, {\n            type: 'TASK_PROGRESS',\n            id: message.id,\n            payload: {\n                running: runner?.isRunning() ?? false\n            },\n        });\n    }\n\n    private async handleResolveProjectPath(\n        ws: WebSocket,\n        message: ClientMessage\n    ): Promise<void> {\n        const payload = message.payload as ResolveProjectPathPayload;\n        const port = payload?.port;\n\n        if (!port) {\n            this.send(ws, {\n                type: 'PROJECT_PATH_RESOLVED',\n                id: message.id,\n                payload: { projectPath: null, error: 'No port provided' },\n            });\n            return;\n        }\n\n        console.log(`[VDev Bridge] Resolving project path for port ${port}`);\n\n        const projectPath = await resolveProjectPath(port);\n\n        this.send(ws, {\n            type: 'PROJECT_PATH_RESOLVED',\n            id: message.id,\n            payload: { projectPath },\n        });\n    }\n\n    private async handleTerminalData(\n        ws: WebSocket,\n        message: ClientMessage,\n        subscribedSessions: Set<string>\n    ): Promise<void> {\n        const payload = message.payload as TerminalDataPayload;\n        if (!payload) return;\n\n        const { data, projectPath, useYolo } = payload;\n\n        if (projectPath) {\n            const sessionId = this.getSessionId(projectPath);\n            this.subscribeToSession(ws, sessionId, subscribedSessions);\n            await this.ensureSession(sessionId, projectPath, !!useYolo);\n\n            if (data) {\n                this.terminalManager.sendData(sessionId, data);\n            }\n        }\n    }\n\n    private handleTerminalResize(message: ClientMessage): void {\n        // We need sessionId or projectPath to resize correct terminal.\n        // Current payload might not have it if xterm-addon-fit triggers strictly UI event.\n        // But App.tsx sends sendTerminalResize(cols, rows) which needs specific session.\n        // Let's assume the frontend should pass projectPath in payload for resize too if possible?\n        // Or we assume the client is focused on one session.\n        // Current implementation receives projectPath via `sendTerminalResize`.\n\n        const payload = message.payload as any; // Using any to access potential projectPath if we add it\n        if (payload && payload.projectPath) {\n            const sessionId = this.getSessionId(payload.projectPath);\n            this.terminalManager.resize(sessionId, payload.cols, payload.rows);\n        }\n    }\n\n    private handleTerminalReset(message: ClientMessage): void {\n        const payload = message.payload as any;\n        if (payload && payload.projectPath) {\n            const sessionId = this.getSessionId(payload.projectPath);\n            console.log(`[VDev Bridge] RESETTING session for ${payload.projectPath} (Session: ${sessionId})`);\n\n            // 1. Terminate process\n            this.terminalManager.terminateSession(sessionId);\n\n            // 2. Clear history\n            this.terminalManager.clearHistory(sessionId);\n\n            // 3. Clear from active PTYs listener map\n            this.activePtys.delete(sessionId);\n\n            // 4. Force disconnect clients from this session? \n            // Maybe not needed, they will reconnect/re-init if page reloads.\n        }\n    }\n\n    private send(ws: WebSocket, message: ServerMessage): void {\n        if (ws.readyState === WebSocket.OPEN) {\n            ws.send(JSON.stringify(message));\n        }\n    }\n\n    close(): void {\n        // Cancel all running tasks\n        for (const runner of this.runners.values()) {\n            runner.cancel();\n        }\n        this.runners.clear();\n        this.wss.close();\n        console.log('[VDev Bridge] Server closed');\n    }\n}\n","import type { SourceLocation } from '../types';\n\ninterface BuildOptions {\n    source: SourceLocation;\n    instruction: string;\n}\n\n/**\n * Builds prompts for Claude Code CLI\n */\nexport class PromptBuilder {\n    static build(options: BuildOptions): string {\n        const { source, instruction } = options;\n        const startLine = Math.max(1, source.lineNumber - 10);\n        const endLine = source.lineNumber + 10;\n\n        return `\n你需要帮我修改代码。\n\n## 目标位置\n- 文件: ${source.fileName}\n- 行号: ${source.lineNumber}\n- 列号: ${source.columnNumber}\n\n请先使用 view_file 工具查看这个文件的第 ${startLine} 到 ${endLine} 行，了解上下文。\n\n## 任务\n${instruction}\n\n## 要求\n1. 只修改必要的代码，保持代码风格一致\n2. 如果需要添加新组件，请在合适的位置添加 import\n3. 如果需要添加样式，请使用内联样式或在合适的样式文件中添加\n4. 完成后简要说明你做了什么修改\n`.trim();\n    }\n}\n","import { PromptBuilder } from './PromptBuilder';\nimport { TerminalManager } from '../utils/TerminalManager';\nimport type { SourceLocation, ExecuteResult } from '../types';\n\ninterface ExecuteOptions {\n    projectPath: string;\n    source: SourceLocation;\n    instruction: string;\n    onLog?: (log: string) => void;\n    terminalManager: TerminalManager;\n    sessionId: string;\n}\n\n/**\n * Executes Claude Code CLI via the internal TerminalManager (node-pty)\n */\nexport class ClaudeCodeRunner {\n    async execute(options: ExecuteOptions): Promise<ExecuteResult> {\n        const { projectPath, source, instruction, onLog, terminalManager, sessionId } = options;\n\n        const prompt = PromptBuilder.build({ source, instruction });\n\n        try {\n            onLog?.(`[ClaudeRunner] Using session: ${sessionId}`);\n\n            // Ensure session exists and is running\n            // We pass a dummy callback because the WebSocketServer already handles the output for this session\n            // logic in WebSocketServer ensures onData is bound when socket connects.\n            // Here we just need to ensure the process is valid.\n            const session = await terminalManager.getOrCreateSession(\n                sessionId,\n                projectPath,\n                false // Default to safe mode unless otherwise specified? Or maybe we can detect?\n                // Actually, if the session exists, this arg is ignored. If new, it matters.\n                // For now, let's assume the user opens the terminal first or we default to safe.\n            );\n\n            onLog?.('[ClaudeRunner] Sending instruction to terminal...');\n\n            // Send the prompt to the pty process\n            // We add a few newlines to ensure clean input\n            terminalManager.sendData(sessionId, `\\n${prompt}\\n`);\n\n            return {\n                success: true,\n                filesModified: [],\n                messages: [],\n            };\n        } catch (error) {\n            onLog?.(`[ClaudeRunner] Error: ${(error as Error).message}`);\n            throw error;\n        }\n    }\n\n    cancel(): void {\n        // No-op, user cancels in terminal\n    }\n\n    isRunning(): boolean {\n        return false;\n    }\n}\n","import { exec } from 'child_process';\nimport { promisify } from 'util';\nimport * as path from 'path';\nimport * as fs from 'fs';\n\nconst execAsync = promisify(exec);\n\n/**\n * Resolve project root path from a port number using lsof (macOS).\n * This finds the process listening on the given port and extracts its CWD,\n * then searches upward for package.json to find the project root.\n */\nexport async function resolveProjectPath(port: number): Promise<string | null> {\n    try {\n        // Step 1: Find PID of process listening on the port\n        const { stdout: lsofOutput } = await execAsync(\n            `lsof -i :${port} -P -n | grep LISTEN | awk '{print $2}' | head -1`\n        );\n        const pid = lsofOutput.trim();\n\n        if (!pid) {\n            console.log(`[ProjectUtils] No process found listening on port ${port}`);\n            return null;\n        }\n\n        console.log(`[ProjectUtils] Found PID ${pid} for port ${port}`);\n\n        // Step 2: Get the CWD of that process\n        const { stdout: cwdOutput } = await execAsync(\n            `lsof -p ${pid} | grep cwd | awk '{print $NF}'`\n        );\n        const cwd = cwdOutput.trim();\n\n        if (!cwd) {\n            console.log(`[ProjectUtils] Could not determine CWD for PID ${pid}`);\n            return null;\n        }\n\n        console.log(`[ProjectUtils] Process CWD: ${cwd}`);\n\n        // Step 3: Find project root by looking for package.json upward\n        const projectRoot = findProjectRoot(cwd);\n\n        if (projectRoot) {\n            console.log(`[ProjectUtils] Resolved project root: ${projectRoot}`);\n        } else {\n            console.log(`[ProjectUtils] Could not find project root from ${cwd}`);\n        }\n\n        return projectRoot;\n    } catch (error) {\n        console.error('[ProjectUtils] Error resolving project path:', error);\n        return null;\n    }\n}\n\n/**\n * Derive project root path from a source file path.\n * This is more reliable than port-based detection when source files come from different projects.\n */\nexport function deriveProjectPathFromSource(sourceFilePath: string): string | null {\n    if (!sourceFilePath || !path.isAbsolute(sourceFilePath)) {\n        console.log(`[ProjectUtils] Invalid source file path: ${sourceFilePath}`);\n        return null;\n    }\n\n    const dir = path.dirname(sourceFilePath);\n    const projectRoot = findProjectRoot(dir);\n\n    if (projectRoot) {\n        console.log(`[ProjectUtils] Derived project root from source: ${projectRoot}`);\n    } else {\n        console.log(`[ProjectUtils] Could not derive project root from source: ${sourceFilePath}`);\n    }\n\n    return projectRoot;\n}\n\n/**\n * Find project root by searching upward for package.json\n */\nfunction findProjectRoot(startPath: string): string | null {\n    let currentPath = startPath;\n\n    while (currentPath !== '/') {\n        const packageJsonPath = path.join(currentPath, 'package.json');\n\n        if (fs.existsSync(packageJsonPath)) {\n            return currentPath;\n        }\n\n        currentPath = path.dirname(currentPath);\n    }\n\n    return null;\n}\n\n","import * as pty from 'node-pty';\nimport * as os from 'os';\nimport { ToolManager } from './ToolManager';\n\nconst shell = os.platform() === 'win32'\n    ? 'powershell.exe'\n    : (process.env.SHELL || '/bin/zsh');\n\ninterface TerminalSession {\n    pty: pty.IPty;\n    history: string[]; // Circular buffer-ish\n    useYolo: boolean;\n    isReady: boolean;\n}\n\nexport class TerminalManager {\n    private sessions: Map<string, TerminalSession> = new Map();\n    // Persist history for Normal mode sessions by ID\n    private normalModeHistory: Map<string, string[]> = new Map();\n    private readonly MAX_HISTORY_LINES = 1000;\n\n    private _onReady: (sessionId: string) => void = () => { };\n\n    // Register a callback for when a session is ready\n    onReady(callback: (sessionId: string) => void) {\n        this._onReady = callback;\n    }\n\n    clearHistory(id: string): void {\n        const session = this.sessions.get(id);\n        if (session) {\n            session.history = [];\n        }\n        this.normalModeHistory.set(id, []);\n    }\n\n    isSessionReady(id: string): boolean {\n        return this.sessions.get(id)?.isReady || false;\n    }\n\n    async getOrCreateSession(\n        id: string,\n        cwd: string,\n        useYolo: boolean = false\n    ): Promise<pty.IPty> {\n        let sessionWrapper = this.sessions.get(id);\n\n        // If session exists but YOLO mode changed, we MUST restart it to apply new flag\n        if (sessionWrapper && sessionWrapper.useYolo !== useYolo) {\n            console.log(`[TerminalManager] YOLO mode changed for session ${id}. Restarting...`);\n            this.terminateSession(id);\n            sessionWrapper = undefined;\n        }\n\n        if (!sessionWrapper) {\n            console.log(`[TerminalManager] Creating new session for project: ${cwd} (useYolo: ${useYolo})`);\n\n            // Ensure tools are installed before launching\n            await ToolManager.ensureTools();\n\n            console.log(`[TerminalManager] Spawning shell: ${shell} in verified CWD: ${cwd}`);\n\n            const ptyProcess = pty.spawn(shell, [], {\n                name: 'xterm-color',\n                cols: 80,\n                rows: 24,\n                cwd: cwd,\n                env: { ...process.env } as any\n            });\n\n            // History Strategy\n            // History Strategy\n            // We want history for YOLO mode too now to support page reloading\n            let historyArray: string[] = [];\n\n            // Try to restore from normal mode history if switching modes? \n            // Or just keep separate?\n            // User wants history to persist when switching pages (which might look like new init).\n            // So we should persist history by ID regardless of mode?\n            // Actually, getOrCreateSession handles the \"session exists case\" earlier.\n            // This block is only for NEW sessions.\n            // If we are here, it means we are creating a FRESH pty.\n\n            // However, if we want to PERSIST history across pty restarts (like YOLO toggle),\n            // we need to shore it outside.\n            // But here we are just talking about page reload (client reconnect).\n            // Client reconnect should hit the *existing* session if it's still alive.\n\n            // WAIT. If I reload the page, the WS connection closes.\n            // WebSocketServer.ts: handleConnection -> close -> unsubscribe -> delete if empty?\n            // `this.sessionClients.delete(sessionId);` logic in WSS.\n\n            // BUT `TerminalManager` keeps the session alive?\n            // `TerminalManager` stores sessions in `this.sessions`.\n            // There is no auto-cleanup in `TerminalManager` unless process exits.\n\n            // So if I reload page:\n            // 1. Old WS closes.\n            // 2. New WS connects.\n            // 3. New WS sends TERMINAL_INIT.\n            // 4. WSS calls `getOrCreateSession`.\n            // 5. TM finds existing session in `this.sessions`.\n            // 6. Returns existing PTY.\n            // 7. WSS sends history.\n\n            // So why is history empty?\n            // Ah! `historyArray` initialization logic here:\n            // History Strategy\n            // We want history for YOLO mode too now to support page reloading\n\n            if (!this.normalModeHistory.has(id)) {\n                this.normalModeHistory.set(id, []);\n            }\n            historyArray = this.normalModeHistory.get(id)!;\n\n            // If the session is kept alive, `sessionWrapper.history` should have data.\n            // `getHistory` uses `session.history`.\n\n            // Let's look at `getHistory`:\n            /*\n            getHistory(id: string): string {\n                const session = this.sessions.get(id);\n                if (session) {\n                    return session.history.join('');\n                }\n                const normalHistory = this.normalModeHistory.get(id);\n                return normalHistory ? normalHistory.join('') : '';\n            }\n            */\n\n            // If session exists, it returns `session.history`.\n            // If I am in YOLO mode, `session.history` is being populated (line 95).\n\n            // So why empty? \n            // Maybe the session IS being killed?\n\n            // In WSS close handler:\n            // if (clients.size === 0) { ... // Optional: Terminate session if no clients? }\n            // It says \"We still keep the process alive in TerminalManager\".\n\n            // Wait, does checking `isLocalhost` cause a `disconnect` call from frontend?\n            // App.tsx: \n            // useEffect(() => { connect() }, [])\n            // If unmounted? useWebSocket doesn't auto-disconnect on unmount?\n\n            // If I switch to a non-local page:\n            // Content script might stop sending messages?\n            // The extension sidepanel is global for the window.\n            // The sidepanel might NOT unmount if I just switch tabs?\n            // But `App` causes `TerminalPanel` to unmount. \n            // `useWebSocket` hook is still running in `App`.\n\n            // If `isLocalhost` becomes false:\n            // `App` returns \"Not Supported\" UI. \n            // `TerminalPanel` is gone.\n\n            // `useWebSocket` is still connected!\n            // But `onTerminalOutput` logic:\n            // onTerminalOutput: (data) => terminalRef.current?.write(data)\n\n            // `terminalRef.current` is NULL because `TerminalPanel` is unmounted.\n            // So any data arriving during this time is DROPPED by the frontend.\n\n            // When I switch back:\n            // `TerminalPanel` remounts. Term is empty.\n            // `useWebSocket` is ALREADY connected.\n            // `useEffect` -> `sendTerminalInit`.\n\n            // WSS handles `TERMINAL_INIT`.\n            // It subscribes (or re-subscribes).\n            // It calls `ensureSession`.\n            // It calls `getHistory`.\n            // It sends history!\n\n            // So history IS sent.\n            // Why doesn't the terminal show it?\n\n            // Maybe `terminalRef.current` is not ready when `onTerminalOutput` receives history?\n            // `App.tsx`:\n            // useEffect(() => { if(projectPath...) sendTerminalInit(...) }, ...)\n\n            // `useWebSocket` receives message.\n            // `onTerminalOutput` calls `terminalRef.current.write`.\n\n            // If `sendTerminalInit` triggers immediate response, and `TerminalPanel` is just mounting...\n            // `TerminalPanel` uses `useEffect([], ...)` to init xterm.\n            // Ref is assigned inside `useEffect`.\n            // `terminalRef` passed to `TerminalPanel` is `useRef(null)`.\n            // `useImperativeHandle` populates it.\n\n            // Race condition?\n            // `TerminalPanel` mount -> `useImperativeHandle` (sync-ish but ref update might be late?) -> `useEffect`.\n            // `App` useEffect -> `sendTerminalInit`.\n\n            // The `sendTerminalInit` is in a `useEffect`.\n            // `TerminalPanel` is rendered in the return.\n\n            // React render flow:\n            // 1. Render `App` (with `isLocalhost=true`).\n            // 2. Render `TerminalPanel`.\n            // 3. `TerminalPanel` mounts. `useImperativeHandle` runs. Ref is set?\n            // 4. `App` useEffect runs. calls `sendTerminalInit`.\n\n            // Verify `TerminalManager.ts` change first just in case:\n            // Make history persistent for YOLO too.\n            // Because if the session WAS terminated (e.g. error), we lose history.\n            // But the user says \"Switching between local pages is fine\", \"Switching from non-local is fail\".\n            // Switching between local pages -> `TerminalPanel` might stay mounted? Or re-mount very fast?\n\n            // If I go to non-local page, `isLocalhost` is false.\n            // `TerminalPanel` unmounts.\n            // `App` is waiting.\n\n            // If backend sends history, it should work.\n\n            // Let's patch `TerminalManager` to be safe regarding YOLO history \n            // (currently it init to `[]` every time `getOrCreateSession` makes a new one, \n            // preventing persistence if session restarts).\n            // But the main issue might be frontend race.\n\n            // I will apply the TerminalManager fix first as it's definitely \"wrong\" to not have history for YOLO.\n\n            if (!this.normalModeHistory.has(id)) {\n                this.normalModeHistory.set(id, []);\n            }\n            historyArray = this.normalModeHistory.get(id)!;\n\n            // --- Readiness Detection Logic ---\n            // Markers that indicate Claude Code is interactive/ready\n            // e.g. \"Welcome back!\", \"Try\", \"Visual Dev\", or the prompt \"> \" or specific control sequences\n            // Markers that indicate Claude Code is interactive/ready\n            // e.g. \"Welcome back!\", \"Try\", \"Visual Dev\", or the prompt \"> \" or specific control sequences\n            const readyMarkers = [\n                'Welcome back',\n                'Visual Dev', // If we have a custom banner\n                'Try \"',      // Suggestion text (generic)\n                'bypass permissions',\n                '\\u276F',     // The prompt character often used by Claude Code\n                '/model to try', // Hint text often present at startup\n                '> '          // Standard prompt fallback\n            ];\n\n            sessionWrapper = {\n                pty: ptyProcess,\n                history: historyArray,\n                useYolo,\n                isReady: false\n            };\n\n            // Capture output for history & readiness\n            ptyProcess.onData((data) => {\n                if (sessionWrapper) {\n                    sessionWrapper.history.push(data);\n                    if (sessionWrapper.history.length > this.MAX_HISTORY_LINES) {\n                        sessionWrapper.history.shift();\n                    }\n\n                    // Check for readiness if not already ready\n                    if (!sessionWrapper.isReady) {\n                        // Strip ANSI codes for cleaner matching\n                        // eslint-disable-next-line no-control-regex\n                        const cleanData = data.replace(/\\x1B\\[[0-9;]*[a-zA-Z]/g, '');\n\n                        // Log raw and clean data for debugging\n                        console.log(`[TerminalManager] Chunk: ${JSON.stringify(data.substring(0, 50))}... Clean: ${JSON.stringify(cleanData.substring(0, 50))}...`);\n\n                        const hasMarker = readyMarkers.some(marker => cleanData.includes(marker) || data.includes(marker));\n\n                        if (hasMarker) {\n                            sessionWrapper.isReady = true;\n                            console.log(`[TerminalManager] Session ${id} is READY. Match found.`);\n                            this._onReady(id);\n                        }\n                    }\n                }\n            });\n\n            ptyProcess.onExit(({ exitCode, signal }: { exitCode: number; signal?: number }) => {\n                console.log(`[TerminalManager] Session ${id} exited with code ${exitCode}, signal ${signal}`);\n                if (this.sessions.get(id) === sessionWrapper) {\n                    this.sessions.delete(id);\n                }\n            });\n\n            this.sessions.set(id, sessionWrapper);\n\n            // Auto-launch ccr code\n            const launchCmd = useYolo ? 'ccr code --dangerously-skip-permissions' : 'ccr code';\n            console.log(`[TerminalManager] Launching: ${launchCmd}`);\n            ptyProcess.write(`${launchCmd}\\r`);\n        } else {\n            // If reusing existing session, it's likely already ready.\n            // We should probably trigger ready immediately if it's been running for a bit?\n            // BUT now we have explicit state.\n            // If session is ALREADY ready, getting it here might need to notify caller?\n            // The caller (WebSocketServer) will verify `isSessionReady`.\n        }\n\n        return sessionWrapper.pty;\n    }\n\n    sendData(id: string, data: string): void {\n        const session = this.sessions.get(id);\n        if (session) {\n            session.pty.write(data);\n        }\n    }\n\n    resize(id: string, cols: number, rows: number): void {\n        const session = this.sessions.get(id);\n        if (session) {\n            try {\n                session.pty.resize(cols, rows);\n            } catch (e) {\n                console.error('[TerminalManager] Resize error:', e);\n            }\n        }\n    }\n\n    terminateSession(id: string): void {\n        const session = this.sessions.get(id);\n        if (session) {\n            const pid = session.pty.pid;\n\n            // Remove immediately to prevent race conditions\n            this.sessions.delete(id);\n\n            try {\n                if (os.platform() !== 'win32') {\n                    try {\n                        process.kill(-pid, 'SIGKILL');\n                    } catch (e: any) {\n                        if (e.code !== 'ESRCH') {\n                            console.warn(`[TerminalManager] Failed to kill process group ${pid}, falling back to pty.kill:`, e);\n                            session.pty.kill('SIGKILL');\n                        }\n                    }\n                } else {\n                    session.pty.kill();\n                }\n            } catch (e) {\n                console.error('[TerminalManager] Kill error:', e);\n            }\n        }\n    }\n\n    getHistory(id: string): string {\n        const session = this.sessions.get(id);\n        if (session) {\n            return session.history.join('');\n        }\n\n        // Fallback for sessions that might have been terminated but we want to keep history?\n        // With the new logic, we are storing history in `normalModeHistory` map if !useYolo?\n        // Wait, I updated the creation logic to ALWAYS use `normalModeHistory`.\n        // So checking `normalModeHistory` is correct.\n\n        const history = this.normalModeHistory.get(id);\n        return history ? history.join('') : '';\n    }\n}\n","import { execSync } from 'child_process';\n\nexport class ToolManager {\n    /**\n     * Checks if a command exists in the system PATH\n     */\n    static checkCommand(command: string): boolean {\n        try {\n            execSync(`which ${command}`, { stdio: 'ignore' });\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Checks if both required tools are installed\n     */\n    static checkTools(): { claude: boolean; ccr: boolean } {\n        return {\n            claude: this.checkCommand('claude'),\n            ccr: this.checkCommand('ccr'),\n        };\n    }\n\n    /**\n     * Attempts to install the missing tools\n     */\n    static async installTools(): Promise<boolean> {\n        const { claude, ccr } = this.checkTools();\n\n        if (claude && ccr) {\n            console.log('[ToolManager] All tools are already installed.');\n            return true;\n        }\n\n        try {\n            if (!claude) {\n                console.log('[ToolManager] Installing @anthropic-ai/claude-code...');\n                execSync('npm install -g @anthropic-ai/claude-code', { stdio: 'inherit' });\n            }\n            if (!ccr) {\n                console.log('[ToolManager] Installing @musistudio/claude-code-router...');\n                execSync('npm install -g @musistudio/claude-code-router', { stdio: 'inherit' });\n            }\n            return true;\n        } catch (error) {\n            console.error(`[ToolManager] Installation failed: ${(error as Error).message}`);\n            return false;\n        }\n    }\n\n    /**\n     * Ensures tools are ready, installs if necessary\n     */\n    static async ensureTools(): Promise<boolean> {\n        const status = this.checkTools();\n        if (status.claude && status.ccr) return true;\n\n        console.log('[ToolManager] Some tools are missing. Attempting auto-installation...');\n        return await this.installTools();\n    }\n}\n"],"mappings":"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","names":["import_child_process"]}