{"version":3,"sources":["../src/index.ts","../src/server/WebSocketServer.ts","../src/claude/PromptBuilder.ts","../src/utils/ProjectUtils.ts","../src/utils/TerminalManager.ts","../src/utils/ToolManager.ts"],"sourcesContent":["import { VDevWebSocketServer } from './server/WebSocketServer';\nimport { TokenAuth } from './auth/TokenAuth';\n\nexport interface ServerOptions {\n    port?: number;\n}\n\n/**\n * Start the Visual Dev Bridge Server\n */\nexport function startServer(options: ServerOptions = {}): VDevWebSocketServer {\n    const port = options.port || 9527;\n\n    console.log('[VDev Bridge] Starting server...');\n\n    const server = new VDevWebSocketServer(port);\n\n    // Handle graceful shutdown\n    process.on('SIGINT', () => {\n        console.log('\\n[VDev Bridge] Shutting down...');\n        server.close();\n        process.exit(0);\n    });\n\n    process.on('SIGTERM', () => {\n        server.close();\n        process.exit(0);\n    });\n\n    return server;\n}\n\n// Re-export types and classes\nexport { VDevWebSocketServer } from './server/WebSocketServer';\n\nexport { PromptBuilder } from './claude/PromptBuilder';\nexport * from './types';\n","import { WebSocketServer, WebSocket } from 'ws';\nimport * as crypto from 'crypto';\nimport { PromptBuilder } from '../claude/PromptBuilder';\nimport { resolveProjectPath, deriveProjectPathFromSource } from '../utils/ProjectUtils';\nimport { TerminalManager } from '../utils/TerminalManager';\nimport type { ClientMessage, ServerMessage, StreamMessage, ResolveProjectPathPayload, TerminalDataPayload, TerminalResizePayload } from '../types';\n\n/**\n * WebSocket server that bridges browser extension to Claude Code CLI\n * No authentication required - for local development use only\n */\nexport class VDevWebSocketServer {\n    private wss: WebSocketServer;\n    private terminalManager: TerminalManager = new TerminalManager();\n\n    // Mapping from sessionId (projectPath hash) to connected clients\n    private sessionClients: Map<string, Set<WebSocket>> = new Map();\n\n    constructor(port: number = 9527) {\n        this.wss = new WebSocketServer({ port });\n\n        this.wss.on('connection', this.handleConnection.bind(this));\n\n        // Listen for readiness events\n        this.terminalManager.onReady((sessionId) => {\n            console.log(`[VDev Bridge] Session ${sessionId} is ready. Broadcasting to clients...`);\n            this.broadcastToSession(sessionId, {\n                type: 'TERMINAL_READY',\n                id: 'broadcast',\n                payload: { sessionId }\n            } as any); // Type cast until we strictly type broadcastToSession arg\n        });\n\n        console.log(`[VDev Bridge] WebSocket server running on ws://localhost:${port}`);\n    }\n\n    private getSessionId(projectPath: string): string {\n        // Use a stable hash of the project path as the session ID\n        return crypto.createHash('md5').update(projectPath).digest('hex');\n    }\n\n    private handleConnection(ws: WebSocket): void {\n        console.log('[VDev Bridge] Client connected');\n        // ephemeral ID for task tracking, though tasks might be better keyed by project now too?\n        // For task execution, we still use one runner per request? \n        // Or should runner be per session?\n        // Currently architecture assumes ephemeral runner. Let's keep clientId for runner/task tracking.\n        const clientId = Math.random().toString(36).substring(7);\n\n        // Track subscriptions for this client to clean up on disconnect\n        const subscribedSessions: Set<string> = new Set();\n\n        ws.on('message', async (data) => {\n            try {\n                const message: ClientMessage = JSON.parse(data.toString());\n\n                // Handle different message types\n                switch (message.type) {\n                    case 'EXECUTE_TASK':\n                        await this.handleExecuteTask(ws, message, subscribedSessions);\n                        break;\n                    case 'RESOLVE_PROJECT_PATH':\n                        await this.handleResolveProjectPath(ws, message);\n                        break;\n                    case 'TERMINAL_DATA':\n                        await this.handleTerminalData(ws, message, subscribedSessions);\n                        break;\n                    case 'TERMINAL_RESIZE':\n                        this.handleTerminalResize(message);\n                        break;\n                    case 'TERMINAL_INIT':\n                        await this.handleTerminalInit(ws, message, subscribedSessions);\n                        break;\n                    case 'TERMINAL_RESET':\n                        this.handleTerminalReset(message);\n                        break;\n                }\n            } catch (error) {\n                console.error('[VDev Bridge] Message error:', error);\n            }\n        });\n\n        ws.on('close', () => {\n            console.log(`[VDev Bridge] Client disconnected`);\n\n            // Unsubscribe from sessions\n            for (const sessionId of subscribedSessions) {\n                const clients = this.sessionClients.get(sessionId);\n                if (clients) {\n                    clients.delete(ws);\n                    if (clients.size === 0) {\n                        this.sessionClients.delete(sessionId);\n                        // Optional: Terminate session if no clients? \n                        // User requested \"reuse existing session\", so we KEEP it alive.\n                        // But maybe we should have a timeout? For now, keep it simple: manual kill or server restart.\n                    }\n                }\n            }\n        });\n    }\n\n    // Track which PTYs we are currently listening to, to handle restarts (Swap PTY)\n    private activePtys: Map<string, any> = new Map();\n\n    private async ensureSession(sessionId: string, projectPath: string, useYolo: boolean = false): Promise<void> {\n        try {\n            // We modify getOrCreateSession signature on the fly if needed, but here it's fine.\n            // If YOLO mode changes, this returns a NEW pty object.\n            const sessionPty = await this.terminalManager.getOrCreateSession(sessionId, projectPath, useYolo);\n\n            const lastPty = this.activePtys.get(sessionId);\n\n            // If we haven't seen this PTY before (New session OR Restarted session), attach listener\n            if (lastPty !== sessionPty) {\n                console.log(`[VDev Bridge] Attaching listener to new PTY for session ${sessionId}`);\n                sessionPty.onData((data: string) => {\n                    this.broadcastToSession(sessionId, data);\n                });\n                this.activePtys.set(sessionId, sessionPty);\n            }\n        } catch (error) {\n            console.error(`[VDev Bridge] Error ensuring session ${sessionId} for project ${projectPath}:`, error);\n            const errorMessage = (error as Error).message || String(error);\n            this.broadcastToSession(sessionId, {\n                type: 'TERMINAL_OUTPUT',\n                id: 'broadcast',\n                payload: { data: `\\r\\n\\x1b[31mError: Failed to ensure terminal session. ${errorMessage}\\r\\nCheck if 'npx' execution environment has correct permissions and 'node-pty' is compatible.\\x1b[0m\\r\\n` }\n            });\n            // We should arguably re-throw or handle the fact that session is not ready?\n            // But for now, notifying the client is key.\n        }\n    }\n\n    private subscribeToSession(ws: WebSocket, sessionId: string, subscribedSessions: Set<string>): void {\n        // Enforce SINGLE active session per client socket.\n        // Iterate over a COPY to safely modify the original Set during iteration.\n        const currentSessions = Array.from(subscribedSessions);\n\n        for (const oldSessionId of currentSessions) {\n            if (oldSessionId !== sessionId) {\n                console.log(`[VDev Bridge] Unsubscribing client from old session: ${oldSessionId}`);\n                const oldClients = this.sessionClients.get(oldSessionId);\n                if (oldClients) {\n                    oldClients.delete(ws);\n                    if (oldClients.size === 0) {\n                        this.sessionClients.delete(oldSessionId);\n                        // We still keep the process alive in TerminalManager\n                    }\n                }\n                subscribedSessions.delete(oldSessionId);\n            }\n        }\n\n        if (!subscribedSessions.has(sessionId)) {\n            console.log(`[VDev Bridge] Subscribing client to new session: ${sessionId}`);\n            if (!this.sessionClients.has(sessionId)) {\n                this.sessionClients.set(sessionId, new Set());\n            }\n            this.sessionClients.get(sessionId)?.add(ws);\n            subscribedSessions.add(sessionId);\n        }\n    }\n\n    private broadcastToSession(sessionId: string, messageOrData: string | object): void {\n        const clients = this.sessionClients.get(sessionId);\n        if (clients && clients.size > 0) {\n            let payload: string;\n\n            if (typeof messageOrData === 'string') {\n                payload = JSON.stringify({\n                    type: 'TERMINAL_OUTPUT',\n                    id: 'stream',\n                    payload: { data: messageOrData }\n                });\n            } else {\n                payload = JSON.stringify(messageOrData);\n            }\n\n            for (const client of clients) {\n                if (client.readyState === WebSocket.OPEN) {\n                    client.send(payload);\n                }\n            }\n        }\n    }\n\n    private async handleTerminalInit(\n        ws: WebSocket,\n        message: ClientMessage,\n        subscribedSessions: Set<string>\n    ): Promise<void> {\n        const payload = message.payload as any;\n        const { projectPath, useYolo } = payload;\n\n        if (!projectPath) return;\n\n        console.log(`[VDev Bridge] Initializing terminal for ${projectPath}`);\n        const sessionId = this.getSessionId(projectPath);\n\n        this.subscribeToSession(ws, sessionId, subscribedSessions);\n        await this.ensureSession(sessionId, projectPath, !!useYolo);\n\n        // Replay history\n        const history = this.terminalManager.getHistory(sessionId);\n        if (history) {\n            this.send(ws, {\n                type: 'TERMINAL_OUTPUT',\n                id: message.id, // Response to INIT\n                payload: { data: history }\n            });\n        }\n\n        // Check readiness\n        if (this.terminalManager.isSessionReady(sessionId)) {\n            console.log(`[VDev Bridge] Session ${sessionId} is already READY. Notifying client.`);\n            this.send(ws, {\n                type: 'TERMINAL_READY',\n                id: message.id,\n                payload: { sessionId }\n            });\n        }\n    }\n\n    private async handleExecuteTask(\n        ws: WebSocket,\n        message: ClientMessage,\n        subscribedSessions: Set<string>\n    ): Promise<void> {\n        const payload = message.payload as { source: { fileName: string; lineNumber: number; columnNumber: number }; instruction: string; projectPath: string };\n        const { source, instruction, projectPath: extensionProvidedPath } = payload;\n\n        const projectPath = deriveProjectPathFromSource(source.fileName) || extensionProvidedPath;\n        const sessionId = this.getSessionId(projectPath);\n\n        console.log(`[VDev Bridge] Executing task for ${projectPath} (Session: ${sessionId})`);\n\n        // Ensure we are subscribed to output\n        this.subscribeToSession(ws, sessionId, subscribedSessions);\n        await this.ensureSession(sessionId, projectPath, false);\n\n        const prompt = PromptBuilder.build({ source, instruction });\n\n        // Send the prompt to the pty process via terminal manager\n        // We add a few newlines to ensure clean input\n        this.terminalManager.sendData(sessionId, `\\n${prompt}\\n`);\n\n        this.send(ws, {\n            type: 'TASK_STARTED',\n            id: message.id,\n            payload: { status: 'running' },\n            projectPath,\n        });\n    }\n\n    private async handleResolveProjectPath(\n        ws: WebSocket,\n        message: ClientMessage\n    ): Promise<void> {\n        const payload = message.payload as ResolveProjectPathPayload;\n        const port = payload?.port;\n\n        if (!port) {\n            this.send(ws, {\n                type: 'PROJECT_PATH_RESOLVED',\n                id: message.id,\n                payload: { projectPath: null, error: 'No port provided' },\n            });\n            return;\n        }\n\n        console.log(`[VDev Bridge] Resolving project path for port ${port}`);\n\n        const projectPath = await resolveProjectPath(port);\n\n        this.send(ws, {\n            type: 'PROJECT_PATH_RESOLVED',\n            id: message.id,\n            payload: { projectPath },\n        });\n    }\n\n    private async handleTerminalData(\n        ws: WebSocket,\n        message: ClientMessage,\n        subscribedSessions: Set<string>\n    ): Promise<void> {\n        const payload = message.payload as TerminalDataPayload;\n        if (!payload) return;\n\n        const { data, projectPath, useYolo } = payload;\n\n        if (projectPath) {\n            const sessionId = this.getSessionId(projectPath);\n            this.subscribeToSession(ws, sessionId, subscribedSessions);\n            try {\n                await this.ensureSession(sessionId, projectPath, !!useYolo);\n                if (data) {\n                    this.terminalManager.sendData(sessionId, data);\n                }\n            } catch (error) {\n                console.error('[VDev Bridge] Error ensuring session likely due to spawn failure:', error);\n                const errorMessage = (error as Error).message || String(error);\n                this.send(ws, {\n                    type: 'TERMINAL_OUTPUT',\n                    id: message.id,\n                    payload: { data: `\\r\\n\\x1b[31mError: Failed to start terminal session. ${errorMessage}\\x1b[0m\\r\\n` }\n                });\n            }\n        }\n    }\n\n    private handleTerminalResize(message: ClientMessage): void {\n        // We need sessionId or projectPath to resize correct terminal.\n        // Current payload might not have it if xterm-addon-fit triggers strictly UI event.\n        // But App.tsx sends sendTerminalResize(cols, rows) which needs specific session.\n        // Let's assume the frontend should pass projectPath in payload for resize too if possible?\n        // Or we assume the client is focused on one session.\n        // Current implementation receives projectPath via `sendTerminalResize`.\n\n        const payload = message.payload as any; // Using any to access potential projectPath if we add it\n        if (payload && payload.projectPath) {\n            const sessionId = this.getSessionId(payload.projectPath);\n            this.terminalManager.resize(sessionId, payload.cols, payload.rows);\n        }\n    }\n\n    private handleTerminalReset(message: ClientMessage): void {\n        const payload = message.payload as any;\n        if (payload && payload.projectPath) {\n            const sessionId = this.getSessionId(payload.projectPath);\n            console.log(`[VDev Bridge] RESETTING session for ${payload.projectPath} (Session: ${sessionId})`);\n\n            // 1. Terminate process\n            this.terminalManager.terminateSession(sessionId);\n\n            // 2. Clear history\n            this.terminalManager.clearHistory(sessionId);\n\n            // 3. Clear from active PTYs listener map\n            this.activePtys.delete(sessionId);\n\n            // 4. Force disconnect clients from this session? \n            // Maybe not needed, they will reconnect/re-init if page reloads.\n        }\n    }\n\n    private send(ws: WebSocket, message: ServerMessage): void {\n        if (ws.readyState === WebSocket.OPEN) {\n            ws.send(JSON.stringify(message));\n        }\n    }\n\n    close(): void {\n        this.wss.close();\n        console.log('[VDev Bridge] Server closed');\n    }\n}\n","import type { SourceLocation } from '../types';\n\ninterface BuildOptions {\n    source: SourceLocation;\n    instruction: string;\n}\n\n/**\n * Builds prompts for Claude Code CLI\n */\nexport class PromptBuilder {\n    static build(options: BuildOptions): string {\n        const { source, instruction } = options;\n        const startLine = Math.max(1, source.lineNumber - 10);\n        const endLine = source.lineNumber + 10;\n\n        return `\n你需要帮我修改代码。\n\n## 目标位置\n- 文件: ${source.fileName}\n- 行号: ${source.lineNumber}\n- 列号: ${source.columnNumber}\n\n请先使用 view_file 工具查看这个文件的第 ${startLine} 到 ${endLine} 行，了解上下文。\n\n## 任务\n${instruction}\n\n## 要求\n1. 只修改必要的代码，保持代码风格一致\n2. 如果需要添加新组件，请在合适的位置添加 import\n3. 如果需要添加样式，请使用内联样式或在合适的样式文件中添加\n4. 完成后简要说明你做了什么修改\n`.trim();\n    }\n}\n","import { exec } from 'child_process';\nimport { promisify } from 'util';\nimport * as path from 'path';\nimport * as fs from 'fs';\n\nconst execAsync = promisify(exec);\n\n/**\n * Resolve project root path from a port number using lsof (macOS).\n * This finds the process listening on the given port and extracts its CWD,\n * then searches upward for package.json to find the project root.\n */\nexport async function resolveProjectPath(port: number): Promise<string | null> {\n    try {\n        // Step 1: Find PID of process listening on the port\n        const { stdout: lsofOutput } = await execAsync(\n            `lsof -i :${port} -P -n | grep LISTEN | awk '{print $2}' | head -1`\n        );\n        const pid = lsofOutput.trim();\n\n        if (!pid) {\n            console.log(`[ProjectUtils] No process found listening on port ${port}`);\n            return null;\n        }\n\n        console.log(`[ProjectUtils] Found PID ${pid} for port ${port}`);\n\n        // Step 2: Get the CWD of that process\n        const { stdout: cwdOutput } = await execAsync(\n            `lsof -p ${pid} | grep cwd | awk '{print $NF}'`\n        );\n        const cwd = cwdOutput.trim();\n\n        if (!cwd) {\n            console.log(`[ProjectUtils] Could not determine CWD for PID ${pid}`);\n            return null;\n        }\n\n        console.log(`[ProjectUtils] Process CWD: ${cwd}`);\n\n        // Step 3: Find project root by looking for package.json upward\n        const projectRoot = findProjectRoot(cwd);\n\n        if (projectRoot) {\n            console.log(`[ProjectUtils] Resolved project root: ${projectRoot}`);\n        } else {\n            console.log(`[ProjectUtils] Could not find project root from ${cwd}`);\n        }\n\n        return projectRoot;\n    } catch (error) {\n        console.error('[ProjectUtils] Error resolving project path:', error);\n        return null;\n    }\n}\n\n/**\n * Derive project root path from a source file path.\n * This is more reliable than port-based detection when source files come from different projects.\n */\nexport function deriveProjectPathFromSource(sourceFilePath: string): string | null {\n    if (!sourceFilePath || !path.isAbsolute(sourceFilePath)) {\n        console.log(`[ProjectUtils] Invalid source file path: ${sourceFilePath}`);\n        return null;\n    }\n\n    const dir = path.dirname(sourceFilePath);\n    const projectRoot = findProjectRoot(dir);\n\n    if (projectRoot) {\n        console.log(`[ProjectUtils] Derived project root from source: ${projectRoot}`);\n    } else {\n        console.log(`[ProjectUtils] Could not derive project root from source: ${sourceFilePath}`);\n    }\n\n    return projectRoot;\n}\n\n/**\n * Find project root by searching upward for package.json\n */\nfunction findProjectRoot(startPath: string): string | null {\n    let currentPath = startPath;\n\n    while (currentPath !== '/') {\n        const packageJsonPath = path.join(currentPath, 'package.json');\n\n        if (fs.existsSync(packageJsonPath)) {\n            return currentPath;\n        }\n\n        currentPath = path.dirname(currentPath);\n    }\n\n    return null;\n}\n\n","import * as pty from 'node-pty';\nimport * as os from 'os';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport { Terminal } from '@xterm/headless';\nimport { SerializeAddon } from '@xterm/addon-serialize';\nimport { ToolManager } from './ToolManager';\n\nconst shell = os.platform() === 'win32'\n    ? 'powershell.exe'\n    : (process.env.SHELL || '/bin/zsh');\n\ninterface TerminalSession {\n    pty: pty.IPty;\n    headless: Terminal;\n    serializer: SerializeAddon;\n    useYolo: boolean;\n    isReady: boolean;\n    historyBuffer: string[]; // Keep a small buffer for readiness detection\n}\n\nexport class TerminalManager {\n    private sessions: Map<string, TerminalSession> = new Map();\n    // Persist serialized state for sessions by ID\n    private persistedState: Map<string, string> = new Map();\n    private readonly READINESS_BUFFER_SIZE = 50;\n\n    private _onReady: (sessionId: string) => void = () => { };\n\n    // Register a callback for when a session is ready\n    onReady(callback: (sessionId: string) => void) {\n        this._onReady = callback;\n    }\n\n    clearHistory(id: string): void {\n        const session = this.sessions.get(id);\n        if (session) {\n            session.headless.reset();\n            session.historyBuffer = [];\n        }\n        this.persistedState.delete(id);\n    }\n\n    isSessionReady(id: string): boolean {\n        return this.sessions.get(id)?.isReady || false;\n    }\n\n    async getOrCreateSession(\n        id: string,\n        cwd: string,\n        useYolo: boolean = false\n    ): Promise<pty.IPty> {\n        let sessionWrapper = this.sessions.get(id);\n\n        // If session exists but YOLO mode changed, we MUST restart it to apply new flag\n        if (sessionWrapper && sessionWrapper.useYolo !== useYolo) {\n            console.log(`[TerminalManager] YOLO mode changed for session ${id}. Restarting...`);\n            this.terminateSession(id);\n            sessionWrapper = undefined;\n        }\n\n        if (!sessionWrapper) {\n            console.log(`[TerminalManager] Creating new session for project: ${cwd} (useYolo: ${useYolo})`);\n\n            // Ensure tools are installed before launching\n            await ToolManager.ensureTools();\n\n            console.log(`[TerminalManager] Spawning shell: ${shell} in verified CWD: ${cwd}`);\n\n            const nodePath = path.dirname(process.execPath);\n            const env = { ...process.env };\n            // Ensure the node executable running this process is in the PATH\n            env.PATH = `${nodePath}${path.delimiter}${env.PATH || ''}`;\n\n            console.log('[TerminalManager] --- Diagnostic Check ---');\n            console.log(`[TerminalManager] Platform: ${os.platform()}, Arch: ${os.arch()}`);\n            console.log(`[TerminalManager] Node Version: ${process.version}`);\n            console.log(`[TerminalManager] Exec Path: ${process.execPath}`);\n            console.log(`[TerminalManager] Shell Path: ${shell}`);\n\n            try {\n                if (fs.existsSync(shell)) {\n                    console.log(`[TerminalManager] Shell exists at ${shell}`);\n                    try {\n                        fs.accessSync(shell, fs.constants.X_OK);\n                        console.log(`[TerminalManager] Shell is executable`);\n                    } catch (e) {\n                        console.error(`[TerminalManager] Shell is NOT executable: ${e}`);\n                    }\n                } else {\n                    console.error(`[TerminalManager] Shell does NOT exist at ${shell}`);\n                }\n            } catch (e) {\n                console.error(`[TerminalManager] Error checking shell: ${e}`);\n            }\n\n            console.log(`[TerminalManager] CWD: ${cwd}`);\n            try {\n                if (fs.existsSync(cwd)) {\n                    console.log(`[TerminalManager] CWD exists`);\n                } else {\n                    console.error(`[TerminalManager] CWD does NOT exist`);\n                }\n            } catch (e) {\n                console.error(`[TerminalManager] Error checking CWD: ${e}`);\n            }\n\n            console.log(`[TerminalManager] PATH: ${env.PATH}`);\n            console.log('[TerminalManager] ------------------------');\n\n\n            let ptyProcess;\n            try {\n                ptyProcess = pty.spawn(shell, [], {\n                    name: 'xterm-color',\n                    cols: 80,\n                    rows: 24,\n                    cwd: cwd,\n                    env: env as any\n                });\n            } catch (error) {\n                console.error('[TerminalManager] Failed to spawn shell:', error);\n                console.error('[TerminalManager] Shell:', shell);\n                console.error('[TerminalManager] CWD:', cwd);\n                throw error;\n            }\n\n            // Create headless terminal\n            const headless = new Terminal({\n                allowProposedApi: true,\n                cols: 80,\n                rows: 24,\n                scrollback: 1000\n            });\n            const serializer = new SerializeAddon();\n            headless.loadAddon(serializer);\n\n            // Restore state if exists\n            const savedState = this.persistedState.get(id);\n            if (savedState) {\n                headless.write(savedState);\n            }\n\n            let historyBuffer: string[] = [];\n\n            // --- Readiness Detection Logic ---\n\n\n            // Markers that indicate Claude Code is interactive/ready\n            // e.g. \"Welcome back!\", \"Try\", \"Visual Dev\", or the prompt \"> \" or specific control sequences\n            const readyMarkers = [\n                'Welcome back',\n                'Visual Dev', // If we have a custom banner\n                'Try \"',      // Suggestion text (generic)\n                'bypass permissions',\n                '\\u276F',     // The prompt character often used by Claude Code\n                '/model to try', // Hint text often present at startup\n                '> '          // Standard prompt fallback\n            ];\n\n            sessionWrapper = {\n                pty: ptyProcess,\n                headless,\n                serializer,\n                useYolo,\n                isReady: false,\n                historyBuffer\n            };\n\n            // Capture output for history & readiness\n            ptyProcess.onData((data) => {\n                if (sessionWrapper) {\n                    // Write to headless terminal for state tracking\n                    sessionWrapper.headless.write(data);\n\n                    // Buffer for readiness detection only\n                    sessionWrapper.historyBuffer.push(data);\n                    if (sessionWrapper.historyBuffer.length > this.READINESS_BUFFER_SIZE) {\n                        sessionWrapper.historyBuffer.shift();\n                    }\n\n                    // Check for readiness if not already ready\n                    if (!sessionWrapper.isReady) {\n                        // eslint-disable-next-line no-control-regex\n                        const cleanData = data.replace(/\\x1B\\[[0-9;]*[a-zA-Z]/g, '');\n                        // Check logic remains same, but we check `data` chunk mainly\n                        const hasMarker = readyMarkers.some(marker => cleanData.includes(marker) || data.includes(marker));\n\n                        if (hasMarker) {\n                            sessionWrapper.isReady = true;\n                            console.log(`[TerminalManager] Session ${id} is READY. Match found.`);\n                            this._onReady(id);\n                        }\n                    }\n                }\n            });\n\n            ptyProcess.onExit(({ exitCode, signal }: { exitCode: number; signal?: number }) => {\n                console.log(`[TerminalManager] Session ${id} exited with code ${exitCode}, signal ${signal}`);\n                if (this.sessions.get(id) === sessionWrapper) {\n                    this.sessions.delete(id);\n                }\n            });\n\n            this.sessions.set(id, sessionWrapper);\n\n            // Auto-launch ccr code\n            const launchCmd = useYolo ? 'ccr code --dangerously-skip-permissions' : 'ccr code';\n            console.log(`[TerminalManager] Launching: ${launchCmd}`);\n            ptyProcess.write(`${launchCmd}\\r`);\n        } else {\n            // If reusing existing session, it's likely already ready.\n            // We should probably trigger ready immediately if it's been running for a bit?\n            // BUT now we have explicit state.\n            // If session is ALREADY ready, getting it here might need to notify caller?\n            // The caller (WebSocketServer) will verify `isSessionReady`.\n        }\n\n        return sessionWrapper.pty;\n    }\n\n    sendData(id: string, data: string): void {\n        const session = this.sessions.get(id);\n        if (session) {\n            session.pty.write(data);\n        }\n    }\n\n    resize(id: string, cols: number, rows: number): void {\n        const session = this.sessions.get(id);\n        if (session) {\n            try {\n                session.pty.resize(cols, rows);\n                session.headless.resize(cols, rows);\n            } catch (e) {\n                console.error('[TerminalManager] Resize error:', e);\n            }\n        }\n    }\n\n    terminateSession(id: string): void {\n        const session = this.sessions.get(id);\n        if (session) {\n            const pid = session.pty.pid;\n\n            // Save state before destroying\n            this.persistedState.set(id, session.serializer.serialize());\n\n            // Clean up headless\n            session.headless.dispose();\n\n            // Remove immediately to prevent race conditions\n            this.sessions.delete(id);\n\n            try {\n                if (os.platform() !== 'win32') {\n                    try {\n                        process.kill(-pid, 'SIGKILL');\n                    } catch (e: any) {\n                        if (e.code !== 'ESRCH') {\n                            console.warn(`[TerminalManager] Failed to kill process group ${pid}, falling back to pty.kill:`, e);\n                            session.pty.kill('SIGKILL');\n                        }\n                    }\n                } else {\n                    session.pty.kill();\n                }\n            } catch (e) {\n                console.error('[TerminalManager] Kill error:', e);\n            }\n        }\n    }\n\n    getHistory(id: string): string {\n        const session = this.sessions.get(id);\n        if (session) {\n            return session.serializer.serialize();\n        }\n\n        return this.persistedState.get(id) || '';\n    }\n}\n","import { execSync } from 'child_process';\n\nexport class ToolManager {\n    /**\n     * Checks if a command exists in the system PATH\n     */\n    static checkCommand(command: string): boolean {\n        try {\n            execSync(`which ${command}`, { stdio: 'ignore' });\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Checks if both required tools are installed\n     */\n    static checkTools(): { claude: boolean; ccr: boolean } {\n        return {\n            claude: this.checkCommand('claude'),\n            ccr: this.checkCommand('ccr'),\n        };\n    }\n\n    /**\n     * Attempts to install the missing tools\n     */\n    static async installTools(): Promise<boolean> {\n        const { claude, ccr } = this.checkTools();\n\n        if (claude && ccr) {\n            console.log('[ToolManager] All tools are already installed.');\n            return true;\n        }\n\n        try {\n            if (!claude) {\n                console.log('[ToolManager] Installing @anthropic-ai/claude-code...');\n                execSync('npm install -g @anthropic-ai/claude-code', { stdio: 'inherit' });\n            }\n            if (!ccr) {\n                console.log('[ToolManager] Installing @musistudio/claude-code-router...');\n                execSync('npm install -g @musistudio/claude-code-router', { stdio: 'inherit' });\n            }\n            return true;\n        } catch (error) {\n            console.error(`[ToolManager] Installation failed: ${(error as Error).message}`);\n            return false;\n        }\n    }\n\n    /**\n     * Ensures tools are ready, installs if necessary\n     */\n    static async ensureTools(): Promise<boolean> {\n        const status = this.checkTools();\n        if (status.claude && status.ccr) return true;\n\n        console.log('[ToolManager] Some tools are missing. Attempting auto-installation...');\n        return await this.installTools();\n    }\n}\n"],"mappings":"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","names":["path","fs","import_child_process"]}